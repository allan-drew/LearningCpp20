#include <iostream>

#include <string>


    ///////////// FUNCTION TEMPLATES 

    /// Function templates are a mechanism in C++ to avoid code repetition, 
    // for example: if you are setting up function overloads

    /// Function templates are just blueprint. 

            // A blueprint is a technical drawing of a home or product 
            // used by the manufacturer to build something.

            // Figuratively, a blueprint is a technical specification used to design software. 
            // In terms of C++ language elements, 
            // a template is a blueprint -- the compiler uses it to generate a class.

    // The compiler generates real C++ code by looking at the aruguments you call your function template with

    // The real C++ function generated by the compiler is called a template instance 

// Um template é uma descrição genérica de uma função
// É definido em termo de tipos genéricos, que podem ser substituídos por tipos reais
// É a base para a programação genérica


// O template não cria nenhuma função, 
// apenas fornece um modelo para o compilador

// O compilador cria as funções com os tipos reais
// a partir das chamadas de funções do programa

///////
template <typename T>
T max ( T a , T b) {
    return ( a > b )? a : b;
}
 

/////////
template <typename T> 
T maximum(T a,T b){
    return (a > b) ? a : b ; 
}

// 



///// Template type parameters by REFERENCE (need to use &)
/// **** If I create another template called 'max', I may confuse the compiler. This is why I did another example ( a template called 'minimum' )
/// A good practice when we use references is to mark our things with "const" to make shure people don't modify thigs without our knowledge 

template <typename T>
const T& minimum ( const T& a2 , const T& b2 ) {
    std::cout << " Inside template - &a2 : " << &a2 << " //// We are passing by reference " << std::endl;
    std::cout << " Inside template - &b2 : " << &b2 << " //// We are passing by reference" << std::endl;
    std::cout << std::endl;

    return ( a2 < b2 )? a2 : b2;
}


int main() {

    ////////////////////////////////// TRYING OUT FUNCTION TEMPLATES /////////////////////
    int x { 5 };
    int y { 7 };
    int result = max ( x , y ); 
        //Whe we call max function, then the compiler will generate a real C++ function. 
        // We can check it out in https://cppinsights.io/
    // As we set up "x" and "y" with "int", the function will replate "T" to "int"
    // If we change "x" and "y" to "double", the function generated will be a double function

    std::cout << " x : " << x << std::endl;
    std::cout << " y : " << y << std::endl;
    std::cout << " MAX RESULT : " << result << std::endl;

    std::cout << std::endl;
    //////////////////////////////////////////////

    double i { 2.2 };
    double j { 3.1 };
    double result_2 = max ( i , j );
    std::cout << " i : " << i << std::endl;
    std::cout << " j : " << j << std::endl;
    std::cout << " MAX RESULT : " << result_2 << std::endl;

    // Repare que : 
        // O template é como se fosse um gerador de funções sobrecarregadas (overloading)
        // Ou seja, cria várias funções com o mesmo nome que têm tipos diferentes nos parâmetros 
        
        // No caso acima, as funções têm o mesmo nome de 'max', 
        // porém os tipos dos parâmetros são diferentes ( int e double )


/*
    /////////////////////////// BE CAREFUL : ////////////
    /// In this case we are comparing the ADDRESSES 
    int* p_x {&x};
    int* p_y{&y};

    auto result_3 = max (p_x , p_y ); ///// In this case we are comparing the ADDRESSES 
    std::cout << " Using pointers..." << std::endl;
    std::cout << " p_x : " << *p_x << " // "  << p_x << std::endl;
    std::cout << " p_y : " << *p_y << " // "  << p_y << std::endl;
    std::cout << "result : " << *result_3 << " ********** BE CAREFUL ********** In this case we are comparing the ADDRESSES  " << std::endl;

    auto result_4 = max ( *p_x , *p_y );
    std::cout << "result : " << result_4 << std::endl;

*/

    std::cout << std::endl;

    /////////////////////////////////// TEMPLATE TYPE DEDUCTION //////////////////////

    int a {13};
    int b {25};
    double c {39.3};
    double d {12.8};
    std::string e{"ALLAN"};
	std::string f{"ANDREW"};

    auto result_5 = max( a , b ); ////// int type DEDUCTION 
    auto result_6 = max( c , d ); ////// double type DEDUCTION 
	auto max_str = maximum( e , f ) ;// string type deduced

    std::cout << " a : " << a << std::endl;
    std::cout << " b : " << b << std::endl;
    std::cout << " MAX RESULT : " << result_5 << std::endl;
    std::cout << std::endl;

    std::cout << " c : " << c << std::endl;
    std::cout << " d : " << d << std::endl;
    std::cout << " MAX RESULT : " << result_6 << std::endl;
    std::cout << std::endl;

    std::cout << " string e : " << e << std::endl;
    std::cout << " string f : " << f << std::endl;
	std::cout << "MAX max_str : " << max_str << std::endl;
    std::cout << std::endl;

    ///////////////////


    ///////////////////////////// EXPLICIT TEMPLATE ARGUMENTS ///////////////////////////
    auto result_8 = max <double> ( a , d); ///// <double> explicit template arguments
    std::cout << " result_8 : " << result_8 << std::endl;

    

    std::cout << std::endl;
    //////////////////////////////////////////////
    std::cout << std::endl;



    /////////////////////// TEMPLATE TYPE PARAMETERS BY REFERENCE //////////////////////
/*

    double a2 = { 25.2 };
    double b2 = { 12.1 };
    std::cout << " Out template (before call the function) - &a2 : " << &a2 << " //// We are passing by reference" << std::endl;
    std::cout << " Out template (before call the function) - &b2 : " << &b2 << " //// We are passing by reference" << std::endl;

    std::cout << std::endl;

    auto result_9 = minimum ( a2 , b2 );

    std::cout << " Out template (after call the function) - &a2 : " << &a2 << " //// We are passing by reference " << std::endl;
    std::cout << " Out template (after call the function) - &b2 : " << &b2 << " //// We are passing by reference" << std::endl;

    std::cout << std::endl;


    std::cout << " Result_9 - minimum between : " << a2 << " and " << b2 << " ==> " << result_9 << std::endl;

*/

    
    std::cout << std::endl;
    //////////////////////////////////////////////
    std::cout << std::endl;



    return 0;
}
